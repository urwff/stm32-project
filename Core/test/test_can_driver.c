/**
 * @file    test_can_driver.c
 * @brief   CAN 驱动测试文件
 * @author  Generated by AI Assistant
 * @date    2025-12-06
 *
 * @note    该测试文件用于验证 can_driver.h 中定义的 CAN 驱动接口
 *          测试方法：在 main.c 中调用 can_driver_run_tests() 执行所有测试
 *
 * @usage   1. 在 main.c 中 #include "test_can_driver.h"
 *          2. 调用 can_driver_run_tests() 运行测试
 *          3. 通过串口查看测试结果
 */

#include "test_can_driver.h"
#include "can_driver.h"
#include <string.h>

/* 私有变量 ---------------------------------------------------------------*/

/** 测试统计信息 */
static uint32_t test_passed = 0;
static uint32_t test_failed = 0;
static uint32_t test_skipped = 0;

/* 私有宏定义 -------------------------------------------------------------*/

/** 断言宏：条件为真则通过，否则失败 */
#define TEST_ASSERT(condition, msg)                                            \
  do {                                                                         \
    if (condition) {                                                           \
      test_passed++;                                                           \
      printf("[PASS] %s\r\n", msg);                                            \
    } else {                                                                   \
      test_failed++;                                                           \
      printf("[FAIL] %s\r\n", msg);                                            \
    }                                                                          \
  } while (0)

/** 断言宏：比较两个整数是否相等 */
#define TEST_ASSERT_EQUAL(expected, actual, msg)                               \
  do {                                                                         \
    if ((expected) == (actual)) {                                              \
      test_passed++;                                                           \
      printf("[PASS] %s (expected=%d, actual=%d)\r\n", msg, (int)(expected),   \
             (int)(actual));                                                   \
    } else {                                                                   \
      test_failed++;                                                           \
      printf("[FAIL] %s (expected=%d, actual=%d)\r\n", msg, (int)(expected),   \
             (int)(actual));                                                   \
    }                                                                          \
  } while (0)

/** 跳过测试宏 */
#define TEST_SKIP(msg)                                                         \
  do {                                                                         \
    test_skipped++;                                                            \
    printf("[SKIP] %s\r\n", msg);                                              \
  } while (0)

/** 打印测试分组信息 */
#define TEST_GROUP_BEGIN(name) printf("\r\n=== %s ===\r\n", name)
#define TEST_GROUP_END() printf("\r\n")

/* 私有函数声明 ------------------------------------------------------------*/

static void test_can_init_loopback_mode(void);
static void test_can_init_normal_mode(void);
static void test_can_filter_config_valid(void);
static void test_can_filter_config_invalid(void);
static void test_can_loopback_transmit_receive(void);
static void test_can_loopback_extended_frame(void);
static void test_can_loopback_remote_frame(void);
static void test_can_get_error(void);
static void test_can_get_pending_messages(void);
static void test_can_transmit_no_mailbox(void);

/* 公开函数实现 ------------------------------------------------------------*/

/**
 * @brief   运行所有 CAN 驱动测试
 * @retval  0: 所有测试通过, -1: 有测试失败
 */
int can_driver_run_tests(void) {
  /* 重置统计信息 */
  test_passed = 0;
  test_failed = 0;
  test_skipped = 0;

  printf("\r\n");
  printf("========================================\r\n");
  printf("      CAN Driver Test Suite Start      \r\n");
  printf("========================================\r\n");

  /* 执行各组测试 */

  /* 测试组 1：初始化测试 */
  TEST_GROUP_BEGIN("CAN Initialization Tests");
  test_can_init_loopback_mode();
  test_can_init_normal_mode();
  TEST_GROUP_END();

  /* 测试组 2：过滤器配置测试 */
  TEST_GROUP_BEGIN("CAN Filter Configuration Tests");
  test_can_filter_config_valid();
  test_can_filter_config_invalid();
  TEST_GROUP_END();

  /* 测试组 3：环回模式收发测试（需要先初始化为环回模式） */
  TEST_GROUP_BEGIN("CAN Loopback Transmit/Receive Tests");

  /* 重新初始化为环回模式以便进行自检 */
  int init_ret = CAN_Init(500000, BX_CAN_MODE_LOOPBACK);
  if (init_ret == CAN_INIT_OK) {
    /* 配置一个接受所有 ID 的过滤器 */
    CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0, 0);

    test_can_loopback_transmit_receive();
    test_can_loopback_extended_frame();
    test_can_loopback_remote_frame();
  } else {
    TEST_SKIP("Loopback tests skipped - CAN init failed");
  }
  TEST_GROUP_END();

  /* 测试组 4：状态查询测试 */
  TEST_GROUP_BEGIN("CAN Status Query Tests");
  test_can_get_error();
  test_can_get_pending_messages();
  TEST_GROUP_END();

  /* 测试组 5：边界条件测试 */
  TEST_GROUP_BEGIN("CAN Boundary Condition Tests");
  test_can_transmit_no_mailbox();
  TEST_GROUP_END();

  /* 打印测试结果统计 */
  printf("========================================\r\n");
  printf("          Test Results Summary          \r\n");
  printf("========================================\r\n");
  printf("  Passed:  %lu\r\n", test_passed);
  printf("  Failed:  %lu\r\n", test_failed);
  printf("  Skipped: %lu\r\n", test_skipped);
  printf("  Total:   %lu\r\n", test_passed + test_failed + test_skipped);
  printf("========================================\r\n");

  if (test_failed > 0) {
    printf("  RESULT: FAILED\r\n");
    return -1;
  } else {
    printf("  RESULT: PASSED\r\n");
    return 0;
  }
}

/**
 * @brief   运行 CAN 环回自检（简化版，适合快速验证）
 * @retval  0: 自检通过, -1: 自检失败
 */
int can_driver_self_test(void) {
  int ret;

  printf("\r\n[Self-Test] CAN Loopback Self-Test Starting...\r\n");

  /* 步骤 1：初始化为环回模式 */
  ret = CAN_Init(500000, BX_CAN_MODE_LOOPBACK);
  if (ret != CAN_INIT_OK) {
    printf("[Self-Test] FAIL: CAN_Init returned %d\r\n", ret);
    return -1;
  }
  printf("[Self-Test] CAN Init OK (Loopback mode, 500kbps)\r\n");

  /* 步骤 2：配置过滤器接受所有报文 */
  ret = CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0,
                         0);
  if (ret != CAN_FILTER_OK) {
    printf("[Self-Test] FAIL: CAN_FilterConfig returned %d\r\n", ret);
    return -1;
  }
  printf("[Self-Test] Filter configured (accept all)\r\n");

  /* 步骤 3：发送测试数据 */
  uint8_t tx_data[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
  uint32_t test_id = 0x123;

  int mailbox = CAN_Transmit(test_id, 0, 0, tx_data, 8);
  if (mailbox < 0) {
    printf("[Self-Test] FAIL: CAN_Transmit returned %d (no mailbox)\r\n",
           mailbox);
    return -1;
  }
  printf("[Self-Test] Transmit OK (mailbox=%d, id=0x%03lX)\r\n", mailbox,
         test_id);

  /* 步骤 4：等待发送完成 */
  ret = CAN_TransmitWait(mailbox, CAN_TIMEOUT_VALUE);
  if (ret != CAN_TX_WAIT_OK) {
    printf("[Self-Test] FAIL: CAN_TransmitWait returned %d\r\n", ret);
    return -1;
  }
  printf("[Self-Test] Transmit wait OK\r\n");

  /* 步骤 5：接收数据 */
  uint32_t rx_id;
  uint8_t rx_ide, rx_rtr, rx_len;
  uint8_t rx_data[8] = {0};

  ret = CAN_Receive(0, &rx_id, &rx_ide, &rx_rtr, rx_data, &rx_len);
  if (ret != CAN_RX_OK) {
    printf("[Self-Test] FAIL: CAN_Receive returned %d\r\n", ret);
    return -1;
  }
  printf("[Self-Test] Receive OK (id=0x%03lX, len=%d)\r\n", rx_id, rx_len);

  /* 步骤 6：验证数据 */
  if (rx_id != test_id) {
    printf("[Self-Test] FAIL: ID mismatch (expected=0x%03lX, "
           "actual=0x%03lX)\r\n",
           test_id, rx_id);
    return -1;
  }

  if (rx_len != 8) {
    printf("[Self-Test] FAIL: Length mismatch (expected=8, actual=%d)\r\n",
           rx_len);
    return -1;
  }

  if (memcmp(tx_data, rx_data, 8) != 0) {
    printf("[Self-Test] FAIL: Data mismatch\r\n");
    printf("  TX: %02X %02X %02X %02X %02X %02X %02X %02X\r\n", tx_data[0],
           tx_data[1], tx_data[2], tx_data[3], tx_data[4], tx_data[5],
           tx_data[6], tx_data[7]);
    printf("  RX: %02X %02X %02X %02X %02X %02X %02X %02X\r\n", rx_data[0],
           rx_data[1], rx_data[2], rx_data[3], rx_data[4], rx_data[5],
           rx_data[6], rx_data[7]);
    return -1;
  }

  printf("[Self-Test] Data verified OK\r\n");
  printf("[Self-Test] PASSED\r\n\r\n");

  return 0;
}

/* 私有函数实现 ------------------------------------------------------------*/

/**
 * @brief   测试 CAN 环回模式初始化
 */
static void test_can_init_loopback_mode(void) {
  int ret = CAN_Init(500000, BX_CAN_MODE_LOOPBACK);
  TEST_ASSERT_EQUAL(CAN_INIT_OK, ret, "CAN_Init loopback mode 500kbps");
}

/**
 * @brief   测试 CAN 正常模式初始化
 * @note    正常模式需要实际 CAN 总线连接才能正常工作
 */
static void test_can_init_normal_mode(void) {
  /* 跳过此测试因为没有实际 CAN 总线 */
  TEST_SKIP("CAN_Init normal mode (requires actual CAN bus)");
}

/**
 * @brief   测试有效的过滤器配置
 */
static void test_can_filter_config_valid(void) {
  int ret;

  /* 先初始化 CAN */
  CAN_Init(500000, BX_CAN_MODE_LOOPBACK);

  /* 测试 32 位掩码模式 */
  ret = CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0,
                         0x123, 0x7FF);
  TEST_ASSERT_EQUAL(CAN_FILTER_OK, ret, "Filter config: 32-bit mask mode");

  /* 测试 32 位列表模式 */
  ret = CAN_FilterConfig(1, CAN_FILTER_MODE_LIST, CAN_FILTER_SCALE_32BIT, 0,
                         0x100, 0x200);
  TEST_ASSERT_EQUAL(CAN_FILTER_OK, ret, "Filter config: 32-bit list mode");

  /* 测试 16 位掩码模式 */
  ret = CAN_FilterConfig(2, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_16BIT, 1,
                         0x123, 0x7FF);
  TEST_ASSERT_EQUAL(CAN_FILTER_OK, ret, "Filter config: 16-bit mask mode");

  /* 测试 16 位列表模式 */
  ret = CAN_FilterConfig(3, CAN_FILTER_MODE_LIST, CAN_FILTER_SCALE_16BIT, 1,
                         0x100, 0x200);
  TEST_ASSERT_EQUAL(CAN_FILTER_OK, ret, "Filter config: 16-bit list mode");

  /* 测试边界过滤器编号 */
  ret = CAN_FilterConfig(13, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0,
                         0);
  TEST_ASSERT_EQUAL(CAN_FILTER_OK, ret, "Filter config: max filter number 13");
}

/**
 * @brief   测试无效的过滤器配置
 */
static void test_can_filter_config_invalid(void) {
  int ret;

  /* 测试无效过滤器编号 */
  ret = CAN_FilterConfig(14, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0,
                         0);
  TEST_ASSERT_EQUAL(CAN_FILTER_PARAM_ERROR, ret,
                    "Filter config: invalid filter number 14");

  /* 测试无效 FIFO 编号 */
  ret = CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 2, 0,
                         0);
  TEST_ASSERT_EQUAL(CAN_FILTER_PARAM_ERROR, ret,
                    "Filter config: invalid FIFO 2");
}

/**
 * @brief   测试环回模式下的标准帧收发
 */
static void test_can_loopback_transmit_receive(void) {
  uint8_t tx_data[8] = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22};
  uint32_t test_id = 0x321;

  /* 发送标准数据帧 */
  int mailbox = CAN_Transmit(test_id, 0, 0, tx_data, 8);
  TEST_ASSERT(mailbox >= 0 && mailbox <= 2, "Loopback: Transmit success");

  if (mailbox >= 0) {
    /* 等待发送完成 */
    int wait_ret = CAN_TransmitWait(mailbox, CAN_TIMEOUT_VALUE);
    TEST_ASSERT_EQUAL(CAN_TX_WAIT_OK, wait_ret, "Loopback: TransmitWait OK");

    /* 接收数据 */
    uint32_t rx_id;
    uint8_t rx_ide, rx_rtr, rx_len;
    uint8_t rx_data[8] = {0};

    int rx_ret = CAN_Receive(0, &rx_id, &rx_ide, &rx_rtr, rx_data, &rx_len);
    TEST_ASSERT_EQUAL(CAN_RX_OK, rx_ret, "Loopback: Receive success");

    /* 验证接收数据 */
    TEST_ASSERT_EQUAL(test_id, rx_id, "Loopback: ID match");
    TEST_ASSERT_EQUAL(0, rx_ide, "Loopback: Standard frame");
    TEST_ASSERT_EQUAL(0, rx_rtr, "Loopback: Data frame");
    TEST_ASSERT_EQUAL(8, rx_len, "Loopback: Data length 8");
    TEST_ASSERT(memcmp(tx_data, rx_data, 8) == 0, "Loopback: Data match");
  }
}

/**
 * @brief   测试环回模式下的扩展帧收发
 */
static void test_can_loopback_extended_frame(void) {
  uint8_t tx_data[4] = {0x01, 0x02, 0x03, 0x04};
  uint32_t test_id = 0x12345678; /* 29 位扩展 ID */

  /* 发送扩展数据帧 */
  int mailbox = CAN_Transmit(test_id, 1, 0, tx_data, 4);
  TEST_ASSERT(mailbox >= 0 && mailbox <= 2, "Extended frame: Transmit success");

  if (mailbox >= 0) {
    /* 等待发送完成 */
    int wait_ret = CAN_TransmitWait(mailbox, CAN_TIMEOUT_VALUE);
    TEST_ASSERT_EQUAL(CAN_TX_WAIT_OK, wait_ret, "Extended frame: Wait OK");

    /* 接收数据 */
    uint32_t rx_id;
    uint8_t rx_ide, rx_rtr, rx_len;
    uint8_t rx_data[8] = {0};

    int rx_ret = CAN_Receive(0, &rx_id, &rx_ide, &rx_rtr, rx_data, &rx_len);
    TEST_ASSERT_EQUAL(CAN_RX_OK, rx_ret, "Extended frame: Receive OK");

    /* 验证扩展帧 */
    TEST_ASSERT_EQUAL(test_id, rx_id, "Extended frame: ID match");
    TEST_ASSERT_EQUAL(1, rx_ide, "Extended frame: IDE=1");
    TEST_ASSERT_EQUAL(4, rx_len, "Extended frame: Length 4");
  }
}

/**
 * @brief   测试环回模式下的远程帧收发
 */
static void test_can_loopback_remote_frame(void) {
  uint32_t test_id = 0x456;

  /* 发送远程帧（无数据） */
  int mailbox = CAN_Transmit(test_id, 0, 1, NULL, 0);
  TEST_ASSERT(mailbox >= 0 && mailbox <= 2, "Remote frame: Transmit success");

  if (mailbox >= 0) {
    /* 等待发送完成 */
    int wait_ret = CAN_TransmitWait(mailbox, CAN_TIMEOUT_VALUE);
    TEST_ASSERT_EQUAL(CAN_TX_WAIT_OK, wait_ret, "Remote frame: Wait OK");

    /* 接收远程帧 */
    uint32_t rx_id;
    uint8_t rx_ide, rx_rtr, rx_len;
    uint8_t rx_data[8] = {0};

    int rx_ret = CAN_Receive(0, &rx_id, &rx_ide, &rx_rtr, rx_data, &rx_len);
    TEST_ASSERT_EQUAL(CAN_RX_OK, rx_ret, "Remote frame: Receive OK");

    /* 验证远程帧 */
    TEST_ASSERT_EQUAL(test_id, rx_id, "Remote frame: ID match");
    TEST_ASSERT_EQUAL(1, rx_rtr, "Remote frame: RTR=1");
  }
}

/**
 * @brief   测试错误状态获取
 */
static void test_can_get_error(void) {
  uint8_t tec, rec, lec;

  /* 初始状态应该没有错误 */
  CAN_Init(500000, BX_CAN_MODE_LOOPBACK);

  uint8_t err_flags = CAN_GetError(&tec, &rec, &lec);

  /* 环回模式下不应该有错误 */
  TEST_ASSERT(err_flags == 0, "GetError: No error flags in loopback");
  TEST_ASSERT(tec == 0, "GetError: TEC=0 in loopback");
  TEST_ASSERT(rec == 0, "GetError: REC=0 in loopback");

  /* 测试 NULL 参数 */
  err_flags = CAN_GetError(NULL, NULL, NULL);
  TEST_ASSERT(err_flags == 0, "GetError: NULL params accepted");
}

/**
 * @brief   测试待处理消息数量获取
 */
static void test_can_get_pending_messages(void) {
  /* 初始化并配置过滤器 */
  CAN_Init(500000, BX_CAN_MODE_LOOPBACK);
  CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0, 0);

  /* 清空 FIFO（读取所有待处理消息） */
  uint32_t id;
  uint8_t ide, rtr, len;
  uint8_t data[8];
  while (CAN_Receive(0, &id, &ide, &rtr, data, &len) == CAN_RX_OK)
    ;

  /* 此时 FIFO0 应该为空 */
  uint8_t pending = CAN_GetPendingMessages(0);
  TEST_ASSERT_EQUAL(0, pending, "GetPending: FIFO0 empty");

  /* 发送一条消息 */
  uint8_t tx_data[4] = {0x01, 0x02, 0x03, 0x04};
  int mailbox = CAN_Transmit(0x100, 0, 0, tx_data, 4);
  if (mailbox >= 0) {
    CAN_TransmitWait(mailbox, CAN_TIMEOUT_VALUE);

    /* 现在应该有 1 条待处理消息 */
    pending = CAN_GetPendingMessages(0);
    TEST_ASSERT_EQUAL(1, pending, "GetPending: FIFO0 has 1 message");

    /* 清空 */
    CAN_Receive(0, &id, &ide, &rtr, data, &len);
  }
}

/**
 * @brief   测试发送邮箱耗尽情况
 * @note    快速连续发送多条消息，尝试耗尽所有邮箱
 */
static void test_can_transmit_no_mailbox(void) {
  CAN_Init(500000, BX_CAN_MODE_LOOPBACK);
  CAN_FilterConfig(0, CAN_FILTER_MODE_MASK, CAN_FILTER_SCALE_32BIT, 0, 0, 0);

  uint8_t tx_data[8] = {0};
  int results[4];

  /* 快速发送 4 条消息（超过 3 个邮箱） */
  for (int i = 0; i < 4; i++) {
    results[i] = CAN_Transmit(0x100 + i, 0, 0, tx_data, 8);
  }

  /* 前 3 条应该成功（返回邮箱号 0-2） */
  TEST_ASSERT(results[0] >= 0, "No mailbox test: 1st transmit OK");
  TEST_ASSERT(results[1] >= 0, "No mailbox test: 2nd transmit OK");
  TEST_ASSERT(results[2] >= 0, "No mailbox test: 3rd transmit OK");

  /* 第 4 条可能失败（如果前 3 条还没发完） */
  /* 注意：在环回模式下发送很快，所以第 4 条也可能成功 */
  if (results[3] == CAN_TX_NO_MAILBOX) {
    printf("[PASS] No mailbox test: 4th transmit got NO_MAILBOX\r\n");
    test_passed++;
  } else if (results[3] >= 0) {
    printf("[INFO] No mailbox test: 4th transmit also OK (fast loopback)\r\n");
    /* 不算失败，因为环回模式发送很快 */
  }

  /* 等待所有发送完成并清空接收 */
  for (int i = 0; i < 3; i++) {
    if (results[i] >= 0) {
      CAN_TransmitWait(results[i], CAN_TIMEOUT_VALUE);
    }
  }

  /* 清空接收缓冲 */
  uint32_t id;
  uint8_t ide, rtr, len;
  uint8_t rx_data[8];
  while (CAN_Receive(0, &id, &ide, &rtr, rx_data, &len) == CAN_RX_OK)
    ;
}
